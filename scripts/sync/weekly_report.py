#!/usr/bin/env python3
"""
Weekly Report

Generates a markdown report of all tasks completed in the past week.
"""

import argparse
import json
import subprocess
from datetime import datetime, timedelta
from pathlib import Path
from collections import defaultdict


REPORTS_DIR = Path("/home/raven/Vault/Soapbox/Work/Tasks/Reports")


def run_task_command(*args):
    """Run a taskwarrior command and return JSON output."""
    cmd = ["task", "rc.confirmation=off", "rc.verbose=nothing", "rc.json.array=on"]
    cmd.extend(args)

    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.stdout.strip():
        try:
            return json.loads(result.stdout)
        except json.JSONDecodeError:
            return []
    return []


def get_completed_tasks_this_week():
    """Get all tasks completed in the last 7 days."""
    tasks = run_task_command("status:completed", "end.after:today-7d", "export")
    return tasks if isinstance(tasks, list) else []


def format_date(date_str):
    """Format Taskwarrior date string to readable format."""
    if not date_str:
        return ""
    try:
        dt = datetime.strptime(date_str[:8], "%Y%m%d")
        return dt.strftime("%Y-%m-%d")
    except:
        return date_str


def generate_weekly_report():
    """Generate the weekly report markdown content."""
    tasks = get_completed_tasks_this_week()

    today = datetime.now()
    week_num = today.isocalendar()[1]
    year = today.year
    week_start = today - timedelta(days=today.weekday() + 7)  # Start of last week
    week_end = today

    lines = [
        f"# Weekly Report - {year}-W{week_num:02d}",
        f"",
        f"**Period:** {week_start.strftime('%Y-%m-%d')} to {week_end.strftime('%Y-%m-%d')}",
        f"**Generated:** {today.strftime('%Y-%m-%d %H:%M')}",
        f"",
        f"---",
        f"",
    ]

    if not tasks:
        lines.append("_No tasks completed this week._")
        return "\n".join(lines)

    # Group tasks by project/source
    by_project = defaultdict(list)
    gitlab_tasks = []
    other_tasks = []

    for task in tasks:
        gitlab_project = task.get('gitlab_project')
        project = task.get('project')

        if gitlab_project:
            gitlab_tasks.append(task)
        elif project:
            by_project[project].append(task)
        else:
            other_tasks.append(task)

    # Summary
    lines.append(f"## Summary")
    lines.append(f"")
    lines.append(f"- **Total tasks completed:** {len(tasks)}")
    lines.append(f"- **GitLab tasks:** {len(gitlab_tasks)}")
    lines.append(f"- **Other tasks:** {len(other_tasks) + sum(len(t) for t in by_project.values())}")
    lines.append(f"")

    # GitLab Tasks Section
    if gitlab_tasks:
        lines.append(f"## GitLab Tasks ({len(gitlab_tasks)})")
        lines.append(f"")

        # Group GitLab tasks by project
        gitlab_by_project = defaultdict(list)
        for task in gitlab_tasks:
            proj = task.get('gitlab_project', 'Unknown')
            gitlab_by_project[proj].append(task)

        for proj, proj_tasks in sorted(gitlab_by_project.items()):
            lines.append(f"### {proj}")
            lines.append(f"")
            for task in proj_tasks:
                desc = task.get('description', 'No description')
                completed = format_date(task.get('end', ''))
                url = task.get('gitlab_url', '')

                if url:
                    lines.append(f"- [x] [{desc}]({url}) - completed {completed}")
                else:
                    lines.append(f"- [x] {desc} - completed {completed}")
            lines.append(f"")

    # Tasks by Project
    if by_project:
        lines.append(f"## By Project")
        lines.append(f"")

        for project, proj_tasks in sorted(by_project.items()):
            lines.append(f"### {project} ({len(proj_tasks)})")
            lines.append(f"")
            for task in proj_tasks:
                desc = task.get('description', 'No description')
                completed = format_date(task.get('end', ''))
                lines.append(f"- [x] {desc} - completed {completed}")
            lines.append(f"")

    # Other Tasks
    if other_tasks:
        lines.append(f"## Other Tasks ({len(other_tasks)})")
        lines.append(f"")
        for task in other_tasks:
            desc = task.get('description', 'No description')
            completed = format_date(task.get('end', ''))
            lines.append(f"- [x] {desc} - completed {completed}")
        lines.append(f"")

    # Footer
    lines.append(f"---")
    lines.append(f"_Generated by weekly_report.py_")

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description="Generate weekly task completion report"
    )
    parser.add_argument(
        "-o", "--output",
        type=Path,
        default=REPORTS_DIR,
        help=f"Output directory (default: {REPORTS_DIR})"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print output to stdout instead of saving to file"
    )
    args = parser.parse_args()

    print("Fetching completed tasks from the past week...")
    tasks = get_completed_tasks_this_week()
    print(f"  Found {len(tasks)} completed tasks")

    print("Generating report...")
    content = generate_weekly_report()

    if args.dry_run:
        print("\n" + "=" * 60 + "\n")
        print(content)
    else:
        args.output.mkdir(parents=True, exist_ok=True)
        today = datetime.now()
        week_num = today.isocalendar()[1]
        year = today.year
        filename = f"{year}-W{week_num:02d}-report.md"
        filepath = args.output / filename
        filepath.write_text(content)
        print(f"\nSaved to: {filepath}")


if __name__ == "__main__":
    main()
